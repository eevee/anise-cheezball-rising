; Constants
BUTTON_RIGHT  EQU 0
BUTTON_LEFT   EQU 1
BUTTON_UP     EQU 2
BUTTON_DOWN   EQU 3
BUTTON_A      EQU 4
BUTTON_B      EQU 5
BUTTON_START  EQU 6
BUTTON_SELECT EQU 7


; Interrupt addresses
SECTION "Vblank interrupt", ROM0[$0040]
    ld a, $01
    ld hl, vblank_flag
    ld [hl], a
    reti

SECTION "LCD controller status interrupt", ROM0[$0048]
    ; I think this happens when the screen is updating and hits a user-specified row, so this is where you'd do stuff like wavy screen effects
    reti

SECTION "Timer overflow interrupt", ROM0[$0050]
    reti

SECTION "Serial transfer completion interrupt", ROM0[$0058]
    reti

SECTION "P10-P13 signal low edge interrupt", ROM0[$0060]
    ; ???
    reti

; Control starts here, but there's more ROM header several bytes later, so the
; only thing we can really do is immediately jump to after the header
SECTION "init", ROM0[$0100]
    nop
    jp $0150

; Initialization and whatnot
SECTION "main", ROM0[$0150]
    ; Enable interrupts
    ld a, %00000001  ; only vblank
    ldh [$FFFF], a
    ; This instruction enables whichever interrupts are enabled according to FFFF
    ei

    ; Set LCD palette for grayscale mode; yes, it has a palette
    ld a, %11100100
    ld [$FF00+$47], a

    ; LCDC
    ; TODO document flags etc
    ld a, %10010111
    ldh [$ff40], a

    ; Set a color palette.  Those aren't exposed directly in main RAM; instead,
    ; you have to write to a register, which will then write the palette to...
    ; somewhere.  Also, colors are two bytes (RGB555), but the register is only
    ; one byte, which complicates things a bit more.
    ; Luckily, if we set the high bit of the control register to 1, it
    ; auto-increments every time we write to the write register, meaning...
    ; well, it looks like this.
    ld a, %10000000
    ld [$FF00+$68], a

    ld bc, %0111110000000000  ; red
    ld a, c
    ld [$FF00+$69], a
    ld a, b
    ld [$FF00+$69], a
    ld bc, %0000001111100000  ; green
    ld a, c
    ld [$FF00+$69], a
    ld a, b
    ld [$FF00+$69], a
    ld bc, %0000000000011111  ; blue
    ld a, c
    ld [$FF00+$69], a
    ld a, b
    ld [$FF00+$69], a
    ld bc, %0111111111111111  ; white
    ld a, c
    ld [$FF00+$69], a
    ld a, b
    ld [$FF00+$69], a

    ; Set CHR tile 0 to be vertical stripes.  The map defaults to all zeroes,
    ; so the screen will just fill with this
    ; TODO i think i'm supposed to only do this with DMA or during a vblank or something??
    ; TODO wait, i thought the background was at 8800 by default, augh
    ld hl, $8000
    ld bc, `00112233
    REPT 8
    ld a, b
    ld [hl+], a
    ld a, c
    ld [hl+], a
    ENDR


    ; Same thing but for an object palette
    ld a, %10000000
    ld [$FF00+$6A], a

    ld bc, %0000000000000000  ; transparent
    ld a, c
    ld [$FF00+$6B], a
    ld a, b
    ld [$FF00+$6B], a
    ld bc, %0010110100100101  ; dark
    ld a, c
    ld [$FF00+$6B], a
    ld a, b
    ld [$FF00+$6B], a
    ld bc, %0100000111001101  ; med
    ld a, c
    ld [$FF00+$6B], a
    ld a, b
    ld [$FF00+$6B], a
    ld bc, %0100001000010001  ; white
    ld a, c
    ld [$FF00+$6B], a
    ld a, b
    ld [$FF00+$6B], a

    ; Define an object
    ld hl, $8800
    ld bc, ANISE_SPRITE
    REPT 32
    ld a, [bc]
    ld [hl+], a
    inc bc
    ENDR

    ; Put an object on the screen, maybe.  Probably not.
    ; TODO this is so illegal
    ld hl, oam_buffer
    ; y-coord
    ld a, 64
    ld [hl+], a
    ; x-coord
    ld [hl+], a
    ; chr index
    ld a, 128
    ld [hl+], a
    ; attributes
    ld a, %00000000
    ld [hl+], a

    ; DMA something
    ld bc, DMA_BYTECODE
    ld hl, $FF80
    REPT 13
    ld a, [bc]
    inc bc
    ld [hl+], a
    ENDR



vblank_loop:
    ; Main loop: halt, wait for a vblank, then do stuff
    halt
    nop
    ; TODO is there any reason to do this, versus just checking the register that says whether it was a vblank interrupt?
    ld hl, vblank_flag
    ld a, [hl]
    and a
    jr z, vblank_loop
    ld a, $00
    ld [hl], a

    ; Use DMA to update object attribute memory.
    ; Do this FIRST to ensure that it happens before the screen starts to update again.
    call $FF80

    ; Poll input
    ; The direct hardware access is nonsense and unreliable, so just read once per frame and stick all the button states in a byte
    ld a, $20                   ; read dpad
    ldh [$ff00], a
    ld a, [$ff00]               ; unreliable, so do it twice
    ld a, [$ff00]
    cpl
    and a, $0f                  ; mask off just the dpad bits
    ld b, a                     ; store dpad bits in b

    ld a, $10                   ; read buttons
    ldh [$ff00], a
    ld a, [$ff00]               ; even more unreliable!
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    cpl
    and a, $0f
    swap a
    or a, b
    ld hl, buttons
    ld [hl], a

    ; set b/c to the y/x coordinates
    ld hl, oam_buffer
    ld b, [hl]
    inc hl
    ld c, [hl]
    bit BUTTON_LEFT, a
    jr z, .skip_left
    dec c
.skip_left:
    bit BUTTON_RIGHT, a
    jr z, .skip_right
    inc c
.skip_right:
    bit BUTTON_UP, a
    jr z, .skip_up
    dec b
.skip_up:
    bit BUTTON_DOWN, a
    jr z, .skip_down
    inc b
.skip_down:
    ld [hl], c
    dec hl
    ld [hl], b

    ; Loop again when done
    jr vblank_loop


SECTION "Sprites", ROM0
ANISE_SPRITE:
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00001333
    dw `00001323
    dw `10001233
    dw `01001333
    dw `00113332
    dw `00003002
    dw `00003002

SECTION "DMA Bytecode", ROM0
DMA_BYTECODE:
    db $F5, $3E, $C1, $EA, $46, $FF, $3E, $28, $3D, $20, $FD, $F1, $D9

SECTION "Important twiddles", WRAM0[$C000]
vblank_flag:
    db
buttons:
    db

SECTION "OAM Buffer", WRAM0[$C100]
oam_buffer:
    ds 4 * 40
