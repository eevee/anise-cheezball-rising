; Constants
BUTTON_RIGHT  EQU 0
BUTTON_LEFT   EQU 1
BUTTON_UP     EQU 2
BUTTON_DOWN   EQU 3
BUTTON_A      EQU 4
BUTTON_B      EQU 5
BUTTON_START  EQU 6
BUTTON_SELECT EQU 7

FACING_DOWN   EQU 0
FACING_UP     EQU 1
FACING_RIGHT  EQU 2
FACING_LEFT   EQU 3

ANIMATION_LENGTH EQU 5

dcolor: MACRO  ; COLOR($rrggbb) -> gbc representation
_r = ((\1) & $ff0000) >> 16 >> 3
_g = ((\1) & $00ff00) >> 8  >> 3
_b = ((\1) & $0000ff) >> 0  >> 3
    dw (_r << 0) | (_g << 5) | (_b << 10)
    ENDM


; Interrupt addresses
SECTION "Vblank interrupt", ROM0[$0040]
    push hl
    ld hl, vblank_flag
    ld [hl], 1
    pop hl
    reti

SECTION "LCD controller status interrupt", ROM0[$0048]
    ; I think this happens when the screen is updating and hits a user-specified row, so this is where you'd do stuff like wavy screen effects
    reti

SECTION "Timer overflow interrupt", ROM0[$0050]
    reti

SECTION "Serial transfer completion interrupt", ROM0[$0058]
    reti

SECTION "P10-P13 signal low edge interrupt", ROM0[$0060]
    ; ???
    reti

DisableLCD: MACRO
    ld a, [$ff40]
    and a, %01111111
    ld [$ff40], a
ENDM

EnableLCD: MACRO
    ld a, [$ff40]
    or a, %10000000
    ld [$ff40], a
ENDM

; Control starts here, but there's more ROM header several bytes later, so the
; only thing we can really do is immediately jump to after the header
SECTION "init", ROM0[$0100]
    nop
    jp main

SECTION "whatever", ROM0
dma_copy:
    ld a, $c1
    ldh [$ff46], a              ; begin transfer
    ld a, 40                    ; wait for 160 cycles
.loop:
    dec a
    jr nz, .loop
    ret
dma_copy_end:
    nop

; Initialization and whatnot
SECTION "main", ROM0[$0150]
; DMA copy routine, not used directly but copied into high RAM at startup
main:
    ; Enable interrupts
    ld a, %00000001  ; only vblank
    ldh [$FFFF], a
    ; This instruction enables whichever interrupts are enabled according to FFFF
    ei

.wait_for_vblank:
    halt
    nop
    ld a, [vblank_flag]
    and a
    jr z, .wait_for_vblank
    ld a, 0
    ld [vblank_flag], a

    ; Set LCD palette for grayscale mode; yes, it has a palette
    ld a, %01100100
    ld [$FF00+$47], a

    ; LCDC
    ; TODO document flags etc
    ld a, %00000111
    ldh [$ff40], a

    ; Set a color palette.  Those aren't exposed directly in main RAM; instead,
    ; you have to write to a register, which will then write the palette to...
    ; somewhere.  Also, colors are two bytes (RGB555), but the register is only
    ; one byte, which complicates things a bit more.
    ; Luckily, if we set the high bit of the control register to 1, it
    ; auto-increments every time we write to the write register, meaning...
    ; well, it looks like this.
    ld a, %10000000
    ld [$FF00+$68], a

    ld hl, TEST_PALETTES
    REPT 8
    ld a, [hl+]
    ld [$FF00+$69], a
    ENDR

    ; Load some basic tiles
    ld hl, $9000
    ld bc, TEST_TILES
    ld d, 100
.tile_loop:
    REPT 16
    ld a, [bc]
    inc bc
    ld [hl+], a
    ENDR
    dec d
    jr nz, .tile_loop

    ; Fill the screen buffer with a pattern of grass tiles, where every 2x2
    ; block has a single grass at the top left.  Note that the full screen
    ; buffer is 32x32 tiles, and it ends at $9c00
    ld hl, $9800
    ld bc, TEST_MAP_1
.screen_fill_loop:
    REPT 1024
    ld a, [bc]
    ld [hl+], a
    inc bc
    ENDR


    ; Same thing but for an object palette
    ld a, %10000000
    ldh [$ff6a], a
    ld hl, ANISE_TEST_PALETTES
    REPT 16
    ld a, [hl+]
    ldh [$ff6b], a
    ENDR

    ; Define an object
    ld hl, $8000
    ld bc, ANISE_TEST_TILES
    ld d, 24
.tile_loop2:
    REPT 16
    ld a, [bc]
    inc bc
    ld [hl+], a
    ENDR
    dec d
    jr nz, .tile_loop2

    ld a, FACING_DOWN
    ld [anise_facing], a
    ld a, ANIMATION_LENGTH
    ld [anise_frame_countdown], a

    ; Put an object on the screen, maybe.  Probably not.

    ; ANTENNA
    ld b, 64
    ld c, 64
    ld hl, oam_buffer
    ; y-coord
    ld a, c
    sub a, 6
    ld [hl+], a
    ; x-coord
    ld a, b
    add a, 6
    ld [hl+], a
    ; chr index
    ld a, 0
    ld [hl+], a
    ; attributes
    ld a, %00000000
    ld [hl+], a

    ; LEFT PART
    ; y-coord
    ld a, c
    ld [hl+], a
    ; x-coord
    ld a, b
    ld [hl+], a
    ; chr index
    ld a, 2
    ld [hl+], a
    ; attributes
    ld a, %00000001
    ld [hl+], a

    ; RIGHT PART
    ; y-coord
    ld a, c
    ld [hl+], a
    ; x-coord
    ld a, b
    add a, 8
    ld [hl+], a
    ; chr index
    ld a, 4
    ld [hl+], a
    ; attributes
    ld a, %00000001
    ld [hl+], a

    ; DMA something
    ld bc, dma_copy
    ld hl, $FF80
    REPT dma_copy_end - dma_copy
    ld a, [bc]
    inc bc
    ld [hl+], a
    ENDR

    EnableLCD



vblank_loop:
    ; Main loop: halt, wait for a vblank, then do stuff
    halt
    nop
    ; TODO is there any reason to do this, versus just checking the register that says whether it was a vblank interrupt?
    ld hl, vblank_flag
    ld a, [hl]
    and a
    jr z, vblank_loop
    ld a, $00
    ld [hl], a

    ; Use DMA to update object attribute memory.
    ; Do this FIRST to ensure that it happens before the screen starts to update again.
    call $FF80

    ; Poll input
    ; The direct hardware access is nonsense and unreliable, so just read once per frame and stick all the button states in a byte
    ld a, $20                   ; read dpad
    ldh [$ff00], a
    ld a, [$ff00]               ; unreliable, so do it twice
    ld a, [$ff00]
    cpl
    and a, $0f                  ; mask off just the dpad bits
    ld b, a                     ; store dpad bits in b

    ld a, $10                   ; read buttons
    ldh [$ff00], a
    ld a, [$ff00]               ; even more unreliable!
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    ld a, [$ff00]
    cpl
    and a, $0f
    swap a                      ; put face buttons in high nybble
    or a, b                     ; combine with dpad buttons

    ; a now contains the current buttons
    ld hl, buttons
    ld b, [hl]                  ; b <- previous buttons
    ld [hl], a                  ; a -> current buttons
    cpl
    and a, b
    ld [buttons_released], a    ; a = ~new & old, i.e. released
    ld a, [hl]                  ; a <- current buttons
    cpl
    or a, b
    cpl
    ld [buttons_pressed], a     ; a = ~(~new | old), i.e. pressed
    ld a, [hl]                  ; leave current buttons in a

    ; OK, uh, so, what do i need here
    ; 0. SPRITE
    ; 1. POSE
    ; 2. ANGLE
    ; 3. FRAME
    ; sprites all begin at ANISE_TEST_TILES
    ; a pose is really a list of frames
    ; so, anise data should include:
    ; 
;ANISE_SPRITES EQU ANISE_TEST_TILES
ANISE_SPRITE_COUNT EQU 4
ANISE_SPRITE_PARTS EQU 3
ANISE_SPRITE_UNIQUE EQU 1
ANISE_SPRITE_ANGLED EQU 1

; update facing
; handle movement [OK]
; decide pose
; update portrait

    ; Anise update loop
    ; set b/c to the y/x coordinates
    ld bc, 4
    ; d: is there any movement at all?
    ld d, 0
    bit BUTTON_LEFT, a
    jr z, .skip_left
    ld d, 1
    ld hl, oam_buffer + 1
    dec [hl]
    add hl, bc
    dec [hl]
    add hl, bc
    dec [hl]
.skip_left:
    bit BUTTON_RIGHT, a
    jr z, .skip_right
    ld d, 1
    ld hl, oam_buffer + 1
    inc [hl]
    add hl, bc
    inc [hl]
    add hl, bc
    inc [hl]
.skip_right:
    bit BUTTON_UP, a
    jr z, .skip_up
    ld d, 1
    ld hl, oam_buffer
    dec [hl]
    add hl, bc
    dec [hl]
    add hl, bc
    dec [hl]
.skip_up:
    bit BUTTON_DOWN, a
    jr z, .skip_down
    ld d, 1
    ld hl, oam_buffer
    inc [hl]
    add hl, bc
    inc [hl]
    add hl, bc
    inc [hl]
.skip_down:

    ; Figure out which way we're facing, based on which (if any) button is newly-pressed this frame
    ; TODO hey i could just keep shifting and...  wait is there any point to that, maybe it's faster?
    ld hl, anise_facing
    ld a, [buttons_pressed]
    bit BUTTON_LEFT, a
    jr z, .skip_left2
    ld [hl], FACING_LEFT
    jr .skip_down2
.skip_left2:
    bit BUTTON_RIGHT, a
    jr z, .skip_right2
    ld [hl], FACING_RIGHT
    jr .skip_down2
.skip_right2:
    bit BUTTON_UP, a
    jr z, .skip_up2
    ld [hl], FACING_UP
    jr .skip_down2
.skip_up2:
    bit BUTTON_DOWN, a
    jr z, .skip_down2
    ld [hl], FACING_DOWN
.skip_down2:

    ld a, d
    cp a, 0
    jp z, .no_movement

    ld a, [anise_frame_countdown]
    dec a
    ld [anise_frame_countdown], a
    jp nz, .no_movement
    ; TODO i jump when it hits zero, so will this skip a frame, or no because this is one of the frames
    ld a, ANIMATION_LENGTH
    ld [anise_frame_countdown], a
    
    ; Anise has a unique sprite, so overwrite the current tile rather than
    ; changing tiles
    ld hl, ANISE_TEST_TILES

    ; Skip ahead a number of /rows/ of tiles, corresponding to anise's facing
    ld a, [anise_facing]
    and a, %11                      ; cap to 4, just in case
    ; TODO unhardcode frame count (oof)
    ld bc, 4 * 3 * 2 * 16           ; frames * parts * tiles * bytes per tile
.skip_facing_row:
    cp a, 0
    jr z, .done_skip_facing_row
    add hl, bc
    dec a
    jr .skip_facing_row
.done_skip_facing_row:

    ; Note that this part always needs to happen!!  I'm just doing it here to
    ; avoid loading anise_frame again in the next bit
    ; TODO need to reset the frame when direction changes (and when pose changes)
    ld a, [anise_frame]
    inc a
    and a, 4 - 1
    ld [anise_frame], a

    ; Skip ahead 3 sprites * the current frame
    ld bc, 3 * 2 * 16               ; parts * tiles * bytes per tile
.advance_frame:    
    cp a, 0
    jr z, .done_advancing_frame
    add hl, bc
    dec a
    jr .advance_frame
.done_advancing_frame:
    ld b, h
    ld c, l
    ld hl, $8000
    REPT 32 * 3
    ld a, [bc]
    inc bc
    ld [hl+], a
    ENDR


.no_movement:

    ; Loop again when done
    jp vblank_loop


SECTION "Utility code", ROM0
; copy d bytes from bc to hl
copy:
.loop:
    ld a, [bc]
    inc bc
    ld [hl+], a
    dec d
    jr z, .loop
    ret


SECTION "Actor data", ROM0
ANISE_ACTOR_INFO:
    dw ANISE_TEST_TILES
    ; Idle pose
    db 0, 1
    ; Walk pose
    db 0, 4


SECTION "Sprites", ROM0
PALETTE_BG0:
    dcolor $80c870
    dcolor $48b038
    dcolor $ddd49b
    dcolor $aba677
    dcolor $000000
    dcolor $000000
PALETTE_ANISE:
    dcolor $000000
    dcolor $204048
    dcolor $20b0b0
    dcolor $f8f8f8
    dcolor $284858
    dcolor $687080
    dcolor $888080
GRASS_SPRITE:
    dw `00000000
    dw `00000000
    dw `01000100
    dw `01010100
    dw `00010000
    dw `00000000
    dw `00000000
    dw `00000000
BRICK_SPRITE:
    dw `00010000
    dw `00010000
    dw `00010000
    dw `11111111
    dw `00000001
    dw `00000001
    dw `00000001
    dw `11111111
EMPTY_SPRITE:
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
ANISE_SPRITE:
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00000000
    dw `00001333
    dw `00001323
    dw `10001233
    dw `01001333
    dw `00113332
    dw `00003002
    dw `00003002
SPRITE_ANISE_FRONT_1:
    dw `00000111
    dw `00001222
    dw `00012222
    dw `00121222
    dw `00121122
    dw `00121111
    dw `00121122
    dw `00121312
    dw `00121313
    dw `00012132
    dw `00001211
    dw `00000123
    dw `00100123
    dw `00011133
    dw `00000131
    dw `00000010
SPRITE_ANISE_FRONT_2:
    dw `11100000
    dw `22210000
    dw `22221000
    dw `22212100
    dw `22112100
    dw `11112100
    dw `22112100
    dw `21312100
    dw `31312100
    dw `23121000
    dw `11210000
    dw `32100000
    dw `32100000
    dw `33100000
    dw `13100000
    dw `01000000

SECTION "Important twiddles", WRAM0[$C000]
vblank_flag:
    db
buttons:
    db
buttons_pressed:
    db
buttons_released:
    db
anise_facing:
    db
anise_pose:
    db
anise_obj:
    db
anise_frame:
    db
anise_frame_countdown:
    db

SECTION "OAM Buffer", WRAM0[$C100]
oam_buffer:
    ds 4 * 40

include "tilesets/testmap.rgbasm"
include "tilesets/testanise.rgbasm"
