include "inc/vendor/hardware.rgbasm"
include "inc/types/entity.rgbasm"
include "inc/math.rgbasm"

; Constants
STACK_SIZE    EQU $200

BYTES_PER_TILE EQU 16
BYTES_PER_OBJECT EQU 32

SPRITESO_PALETTES EQU 0
SPRITESO_TILES EQU 64

dcolor: MACRO  ; COLOR($rrggbb) -> gbc representation
_r = ((\1) & $ff0000) >> 16 >> 3
_g = ((\1) & $00ff00) >> 8  >> 3
_b = ((\1) & $0000ff) >> 0  >> 3
    dw (_r << 0) | (_g << 5) | (_b << 10)
    ENDM


; Reset vectors
SECTION "rst $00", ROM0[$0000]
    ret
SECTION "rst $08", ROM0[$0008]
    ret
SECTION "rst $10", ROM0[$0010]
    ret
SECTION "rst $18", ROM0[$0018]
    ret
SECTION "rst $20", ROM0[$0020]
    ret
SECTION "rst $28", ROM0[$0028]
    ret
SECTION "rst $30", ROM0[$0030]
    ret
SECTION "rst $38", ROM0[$0038]
    ; NOTE: This is encoded as $ff, so it's a great place to put
    ; a crash handler
    ret

; Interrupt addresses
SECTION "Vblank interrupt", ROM0[$0040]
    push hl
    ld hl, vblank_flag
    ld [hl], 1
    pop hl
    reti

SECTION "LCD controller status interrupt", ROM0[$0048]
    ; I think this happens when the screen is updating and hits a user-specified row, so this is where you'd do stuff like wavy screen effects
    reti

SECTION "Timer overflow interrupt", ROM0[$0050]
    reti

SECTION "Serial transfer completion interrupt", ROM0[$0058]
    reti

SECTION "P10-P13 signal low edge interrupt", ROM0[$0060]
    ; ???
    reti

DisableLCD: MACRO
    ld a, [rLCDC]
    and a, $ff & ~LCDCF_ON
    ld [rLCDC], a
ENDM

EnableLCD: MACRO
    ld a, [rLCDC]
    or a, LCDCF_ON
    ld [rLCDC], a
ENDM

; Control starts here, but there's more ROM header several bytes later, so the
; only thing we can really do is immediately jump to after the header
SECTION "init", ROM0[$0100]
_begin_init:
    nop
    jp start
_end_init:
    ; Fill the rest of the header space with NOPs so the linker
    ; doesn't try to put anything else here (eek!)
    REPT $0150 - $0100 - (_end_init - _begin_init)
    nop
    ENDR

SECTION "DMA routine", ROM0
; DMA copy routine, not used directly but copied into high RAM at startup
dma_copy:
    ld a, $c1
    ldh [rDMA], a               ; begin transfer
    ld a, 40                    ; wait for 160 cycles
.loop:
    dec a
    jr nz, .loop
    ret
dma_copy_end:
    nop

; Reserved stack space
SECTION "Stack", WRAM0[$d000 - STACK_SIZE]
    ds STACK_SIZE

SECTION "High locals", HRAM
h_dma:
    ds dma_copy_end - dma_copy
h_collision_index:
    db
h_our_radius:
    db


; Initialization and whatnot
SECTION "main", ROM0[$0150]
start:
    ; Enable interrupts
    ld a, IEF_VBLANK
    ldh [rIE], a
    ; This instruction enables whichever interrupts are enabled according to FFFF
    ei

    ; Put the stack at the top of bank 0 of WRAM
    ld sp, $d000

    ; Set LCD palette for grayscale mode; yes, it has a palette
    ld a, %01100100
    ld [rBGP], a

    ; LCD controller
    ; Note that the LCD is turned off here; it's re-enabled at
    ; the end of all this loading code
    call wait_for_vblank
    ld a, LCDCF_OBJ16 | LCDCF_OBJON | LCDCF_BGON
    ldh [rLCDC], a

    ; Zero-fill some important stuff
    xor a
    ld [buttons], a
    ld [entity_count], a
    ld hl, oam_buffer
    ld c, 160
    call fill
    ld hl, entities_sorted_x_pos
    ld c, MAX_ENTITIES * 3
    call fill
    ld hl, entities_sorted_y_pos
    ld c, MAX_ENTITIES * 3
    call fill

    ; Set a color palette.  Those aren't exposed directly in main RAM; instead,
    ; you have to write to a register, which will then write the palette to...
    ; somewhere.  Also, colors are two bytes (RGB555), but the register is only
    ; one byte, which complicates things a bit more.
    ; Luckily, if we set the high bit of the control register to 1, it
    ; auto-increments every time we write to the write register, meaning...
    ; well, it looks like this.
    ld a, %10000000
    ld [rBCPS], a

    ld hl, MAP_TEST_PALETTES
    REPT 8
    ld a, [hl+]
    ld [rBCPD], a
    ENDR

    ; Load some basic tiles
    ld hl, $9000
    ld de, MAP_TEST_CHARS
    ld bc, 1600
    call copy16

    ; Read from the test map
    ; TODO good candidate for DMA...?  or maybe not since i should really only be filling the visible screen area
    ld hl, $9800
    ld de, MAP_TEST_DATA
    ld bc, 1024
    call copy16

    ; Same thing but for an object palette
    ld a, %10000000
    ldh [rOCPS], a
    ld hl, SPRITES_ANISE + SPRITESO_PALETTES
    REPT 16
    ld a, [hl+]
    ldh [rOCPD], a
    ENDR
    ld hl, SPRITES_CHEEZBALL + SPRITESO_PALETTES
    REPT 16
    ld a, [hl+]
    ldh [rOCPD], a
    ENDR

    ; Define an object
    ld a, HIGH(SPRITES_ANISE + SPRITESO_TILES)
    ld [anise_sprites_address], a
    ld a, LOW(SPRITES_ANISE + SPRITESO_TILES)
    ld [anise_sprites_address + 1], a

    ; Spawn Anise
    ld a, 0
    ld bc, 64 << 4
    ld de, 64 << 4
    call spawn_entity

    ; Place Cheezball at 96, 72
    ld a, 1
    ld bc, 96 << 4
    ld de, 72 << 4
    call spawn_entity

    ; Load Cheezball's front sprite
    ld hl, SPRITES_CHEEZBALL + SPRITESO_TILES
    ld a, h
    ld [rHDMA1], a
    ld a, l
    ld [rHDMA2], a
    ld a, HIGH($0000)
    ld [rHDMA3], a
    ld a, LOW($0000 + 3 * BYTES_PER_OBJECT)
    ld [rHDMA4], a
    ld a, (BYTES_PER_OBJECT * 3) / 16 - 1
    ld [rHDMA5], a

    ; Copy the DMA copy routine into HRAM
    ld de, dma_copy
    ld hl, h_dma
    ld c, dma_copy_end - dma_copy
    call copy

    EnableLCD

    ; TODO display is kind of undefined on the first loop?

main:
    ; Main loop: wait for a vblank, then do stuff
    call wait_for_vblank

    ; GRAPHICS STUFF -- MUST HAPPEN ASAP, AND FAST!
    ; Only have about a thousand cycles to do everything you
    ; need with VRAM, and that's assuming music doesn't eat into
    ; that time!

    ; Use DMA to copy our OAM buffer into real OAM
    ; DISABLE INTERRUPTS during this -- a timer can still fire
    ; in the middle of it, when the entire memory map is
    ; inaccessible!
    di
    call h_dma
    ei

    ; Update Anise's current sprite.  Use DMA here because...
    ; well, geez, it's too slow otherwise.
    ; TODO that doesn't really bode well in general for me
    ; TODO there should perhaps just be a list of current tiles
    ; that need updating, and to what?  hey how does zelda deal
    ; with animated tiles, I wonder
    ld hl, anise_sprites_address
    ld a, [hl+]
    ld [rHDMA1], a
    ld a, [hl]
    ld [rHDMA2], a
    ld a, HIGH($0000)
    ld [rHDMA3], a
    ld a, LOW($0000)
    ld [rHDMA4], a
    ld a, (BYTES_PER_OBJECT * 3) / 16 - 1
    ld [rHDMA5], a

    ; END GRAPHICS STUFF

    ; Busy-loop until the END of vblank, to make this show up in
    ; bgb's cpu monitor better
    ld hl, rLY
.wait_for_no_vblank:
    ld a, [hl]
    or a
    jr nz, .wait_for_no_vblank

    ; Handle mode switches here, so any graphics stuff from the
    ; previous loop is done with
    ld a, [pending_mode_switch]
    ; Clear the pending mode immediately, so it's gone by the
    ; time the new mode returns here
    push af
    xor a
    ld [pending_mode_switch], a
    pop af
    ; Check mode
    cp a, 1
    jp z, .do_show_dialogue

    call read_input

    ld a, [buttons_pressed]
    bit PADB_A, a
    call nz, handle_player_action

    ; Anise update loop
    ; TODO holding left+right simultaneously no longer produces
    ; zero, boo
    ; TODO maybe handle x/y separately and more... deliberately
    ; TODO prevent SR40?
    xor a
    ld [anise + Entity_vx], a
    ld [anise + Entity_vy], a
    ld a, [buttons]
    bit PADB_LEFT, a
    jr z, .skip_left
    ld hl, anise + Entity_vx
    ld [hl], $f0
.skip_left:
    bit PADB_RIGHT, a
    jr z, .skip_right
    ld hl, anise + Entity_vx
    ld [hl], $10
.skip_right:
    bit PADB_UP, a
    jr z, .skip_up
    ld hl, anise + Entity_vy
    ld [hl], $f0
.skip_up:
    bit PADB_DOWN, a
    jr z, .skip_down
    ld hl, anise + Entity_vy
    ld [hl], $10
.skip_down:

    ; Collision detection!  General approach is as follows:
    ; 1. Check axes separately, x first.
    ; 2. Check continuously.
    ; 3. Ignore anything we're already overlapping.
    ; FIXME this does not handle going OFF the map correctly,
    ; but oh well for now

; TODO put this in its own file; make notes about what
; "inclusive" and "exclusive" mean

; Expands to collision detection code in one of the four
; directions; the code is similar, but not similar enough to
; handle at runtime, alas.
; \1 = axis (0 = x, 1 = y)
; \2 = sign (0 = up/left/negative, 1 = down/right/positive)
; \3 = label to jump to when done with this axis
; Expects the current position to already be in bc.
CheckCollision: MACRO
_is_x = (\1 == 0)
_is_y = (\1 == 1)
_is_neg = (\2 == 0)
_is_pos = (\2 == 1)
IF _is_x
_p_pos EQUS "anise + Entity_x"
_q_pos EQUS "anise + Entity_y"
_p_vel EQUS "anise + Entity_vx"
_q_vel EQUS "anise + Entity_vy"
ELSE
_p_pos EQUS "anise + Entity_y"
_q_pos EQUS "anise + Entity_x"
_p_vel EQUS "anise + Entity_vy"
_q_vel EQUS "anise + Entity_vx"
ENDC

    ; In the following comments:
    ; 'p' is our position along the movement (main) axis
    ; 'r' is the radius
    ; 'Δp' is the movement
    ; 'q' is our position along the perpendicular axis
    ; 'P', 'Q', and 'R' are the corresponding values for an
    ;   entity we may collide with
    ; Also, the pseudofunctions Inc() and Exc() refer to the
    ; tile containing a given point.  The only difference is
    ; when the point lies exactly on a grid line, in which case
    ; the right answer depends on whether the point is from the
    ; top/left edge of a box or the bottom/right.
    ; Points on the bottom/right edge of a box are considered
    ; exclusive bounds, so that an entity can press right up
    ; against a wall (entity's right edge = 32, wall's left edge
    ; = 32) and not be considered to be overlapping it.
    ; Inc() is just the high byte of a 12.4 position.  Exc() is
    ; the high byte after subtracting the minimum possible
    ; motion, which is $000.1.

    ; The general idea is to find all the things we might hit,
    ; put them in order, then see which one blocks us first.
    ; There are two kinds of things we might hit: entities, and
    ; map cells.  Map cells are pretty easy, but entities take a
    ; bit more work, so we need to find the entities first.

    ; So!  Make a list of entities we could collide with.
    xor a
    ld [entities_collidable_count], a

    ; Consider the following, where the square on the left is
    ; trying to move to the dotted outline:
    ;
    ;      p  |-Δp-|
    ;   +-----+....*
    ;   |     |    :
    ;   |     |    :
    ;   |     |  +-÷--+
    ;   +-----+..|.*  |
    ;            |    |
    ;            +----+
    ;
    ; A useful fact is that two AABBs, defined by center and
    ; radius, overlap (along one axis) if the absolute distance
    ; between their centers is less than the sum of their radii.
    ; (This definition avoids the inclusive/exclusive problem,
    ; since touching always means one edge is top/left and one
    ; is bottom/right.)
    ; TODO obvious early check: are we even moving towards it?
    ; You can see from the diagram that we only care about an
    ; entity if it ALREADY overlaps us along the PERPENDICULAR
    ; axis — otherwise, moving towards it would miss it
    ; completely.  In other words, this must be true:
    ;   |q - Q| < r + R
    ; TODO is any faster check feasible?
    ; TODO also, what happens if dx is odd?
    ; TODO also also, is it possible to unit test this stuff
    push bc
    ld a, [_q_pos]
    ld b, a
    ld a, [_q_pos + 1]
    ld c, a
    ; bc = q
IF _is_x
    ld hl, cheezball + Entity_y + 1
ELSE
    ld hl, cheezball + Entity_x + 1
ENDC
    ld a, [hl-]
    sub a, c
    ld e, a
    ld a, [hl]
    sbc a, b
    ld d, a
    ; de = Q - q
    jr nc, .skip_abs\@
    Negate16 de
.skip_abs\@:
    ; de = |Q - q|
    ld hl, ANISE_RADIUS
    ld b, 0
    ld c, [hl]
    ld hl, CHEEZBALL_RADIUS
    Add8To16 bc, [hl]
    ; bc = r + R
    Compare16 de, bc
    ; If de >= bc, they're completely misaligned on the q axis,
    ; and it's impossible to collide with this entity
    jr nc, .skip_cheezball\@

    ; Checking for a collision along the main axis is slightly
    ; trickier.  Collisions shouldn't fire for entities that
    ; already overlap, so we want to check whether ONLY the
    ; dotted part (the area we're moving over/into) would
    ; overlap.  A little doodling reveals that the dotted box
    ; has a center at p ± r + ½Δp, and its radius is ½Δp.
    ; (The ± should have the same sign as Δp.)  Thus, the
    ; following must be true:
    ;   |p ± r + ½Δp - P| < ½Δp + S
    ; TODO should we still run, like, collision handlers for
    ; overlapping entities?  (but then they would run twice.
    ; but also that's not wrong.  hm.)
    ; TODO the ½Δp can be eliminated if we can get rid of the
    ; absolute value, which we CAN do in an earlier pass because
    ; we know which way we're moving...
    ld b, 0
    ld a, [_p_vel]
IF _is_neg
    cpl
    inc a
ENDC
    srl a  ; a = ½Δp
    ld c, a
    ld hl, CHEEZBALL_RADIUS
    Add8To16 bc, [hl]
    ; bc = R + ½Δp
    ld hl, _p_pos
    ld d, [hl]
    inc hl
    ld e, [hl]
    ; de = p
    ld a, [_p_vel]
IF _is_neg
    cpl
    inc a
ENDC
    srl a  ; a = ½Δp
    AddATo16 de
    ; de = p + ½Δp
    ld a, [ANISE_RADIUS]
IF _is_pos
    AddATo16 de
ELSE
    SubAFrom16 de
ENDC
    ; de = p ± r + ½Δp
    ; Find absolute difference of de and P
IF _is_x
    ld hl, cheezball + Entity_x + 1
ELSE
    ld hl, cheezball + Entity_y + 1
ENDC
    ld a, [hl-]
    sub a, e
    ld e, a
    ld a, [hl]
    sbc a, d
    ld d, a
    ; TODO shouldn't i /know/ whether i need this?  can't i
    ; avoid it by just reversing the subtraction if necessary?
    jr nc, .skip_abs2\@
    Negate16 de
.skip_abs2\@:
    ; de = |P - (p ± r + ½Δp)|
    Compare16 bc, de
    jr c, .skip_cheezball\@

    ; We will definitely hit this entity!  Add it to the list,
    ; along with the edge that we're going to hit, so we can
    ; sort it in collision order later.
    ld b, [hl]
    inc hl
    ld c, [hl]
    ld hl, CHEEZBALL_RADIUS
IF _is_pos
    Sub8From16 bc, [hl]
ELSE
    Add8To16 bc, [hl]
ENDC
    ld hl, entities_collidable + 1
    ld [hl], b
    inc hl
    ld [hl], c

    ld a, 1
    ld [entities_collidable_count], a

.skip_cheezball\@:
    pop bc

    xor a
    ldh [h_collision_index], a

    ; Now, for the grid.
    ld hl, ANISE_RADIUS
    ; First, figure out which 'columns' to check along the
    ; p-axis.  (For y motion, these are actually rows.)  The
    ; nearest column that might possibly be relevant is the next
    ; one over from where we currently are (we never collide
    ; with something we already overlap), and the furthest is
    ; the one containing our target position.
    ; Positive: Exc(p + r) + 1 to Exc(p + r + Δp)
    ; Negative: Inc(p - r) - 1 to Inc(p - r + Δp)
    ; At this point, bc should already contain the current
    ; position.  Stick these grid columns in de, with the
    ; closest in d (regardless of sign).
IF _is_pos
    Add8To16 bc, [hl]           ; bc = p + r
    ; Subtract the minimum movement (1 subpixel) to get
    ; the exclusive tile, and leave it like this since we'll
    ; need another exclusive tile in a moment
    dec bc
    ld d, b
    inc d                       ; d = Exc(p + r) + 1
    ; Put the FURTHEST column in e: Exc(p + r + Δp)
    ld hl, _p_vel
    ld a, [hl]
    add a, c
    ld c, a
    ld a, b
    adc a, 0
    ld b, a                     ; bc = p + r + Δp - MIN
    ld e, b                     ; e = Exc(p + r + Δp)
ELSE
    Sub8From16 bc, [hl]         ; bc = p - r
    ld d, b
    dec d                       ; d = Inc(p - r) - 1
    ; Put the FURTHEST column in e: Inc(p - r + Δp)
    ld hl, _p_vel
    ld a, [hl]
    add a, c
    ld c, a
    ld a, b
    adc a, $ff
    ld b, a                     ; bc = p - r + Δp
    ld e, b                     ; e = Inc(p - r + Δp)
ENDC

    ; Loop over columns, adjusting d until it meets e.  Note
    ; that d changes in the direction of movement, so the test
    ; is different depending on sign.  (If d is already beyond
    ; e, this motion doesn't cross a grid line, so there's
    ; nothing to do.)
IF _is_pos
    ld a, e
    cp d
ELSE
    ld a, d
    cp e
ENDC
    jp c, .no_hits\@

    ; For each column we might cross: check whether any of the
    ; rows we currently overlap will block us.
    ; Set bc to the minimum and maximum tile q we /already
    ; touch/, which are Inc(q - r) and Exc(q + r).
    ; TODO document what registers are at various stages here
    ld hl, ANISE_RADIUS
    ; Load c first, since it uses Exc() which means we want
    ; 16-bit decrement
    ld a, [_q_pos + 1]
    add a, [hl]
    ld c, a
    ld a, [_q_pos]
    adc a, 0
    ld b, a
    dec bc
    ld c, b                     ; c = Exc(q + r)
    ld a, [_q_pos + 1]
    sub a, [hl]
    ld a, [_q_pos]
    sbc a, 0
    ld b, a                     ; b = Inc(q - r)

    ld a, [hl]
    ldh [h_our_radius], a

.main_scan\@:
    ; Column scan may run multiple times, so preserve the
    ; initial state of b/c
    push bc

    ; TODO here check for any collision candidates that are up
    ; to this next grid line (or maybe just before it, if that's
    ; easier, idk)

.perpendicular_scan\@:
    ; Fetch flags for this cell
    push bc
IF _is_x
    ; x is d, y is c which is already in place
    ld b, d
ELSE
    ; x is c, y is d
    ld b, c
    ld c, d
ENDC
    call get_cell_flags
    pop bc
    ; Check yon flag
    and a, $01
    jr z, .not_blocked\@
    ; If the flag is set, we're blocked!  This is as far as we
    ; go.  Set p so that we're only just touching this cell.
    ; TODO we should finish up the column scan at least
    ; TODO also should zero out velocity
; NEG: this is slightly different, but also i don't much like
; having this in the middle of this loop anyway
IF _is_pos
    ; Positive case: the tile's starting edge (which is the tile
    ; number and 00), minus our radius
    ld b, d
    xor a
    sub a, [hl]
    ld c, a
    ld a, d
    sbc a, 0
    ld b, a
ELSE
    ; Negative case: the tile's ending edge (which is the tile
    ; number plus one and 00), plus our radius -- but we're
    ; adding our radius to zero so we can skip that bit
    ld b, d
    inc b                       ; b = this cell, plus 1
    ld a, [hl]
    ld c, a                     ; c = our radius
    ; TODO that's a bit redundant, could do this with just a
ENDC

    ld a, b
    ld [_p_pos], a
    ld a, c
    ld [_p_pos + 1], a
    pop bc                      ; restore column scan params (urgh)
    jp \3
.not_blocked\@:
    ; Not blocked, so keep looking
    dec c
    ld a, c
    cp b
    jr nc, .perpendicular_scan\@
    pop bc                      ; restore column scan params

    ; Finished checking one column successfully, so continue on
    ; to the next one
IF _is_pos
    inc d
    ld a, e
    cp d
ELSE
    dec d
    ld a, d
    cp e
ENDC
    jr nc, .main_scan\@

.no_hits\@:
    ; Check for running into cheezball
    ld a, [h_collision_index]
    push hl
    ld hl, entities_collidable_count
    cp a, [hl]
    jr nc, .skip_entity_check\@
    ; OK, haven't hit the end of the entity list yet...
    ld hl, entities_collidable + 1
    ; TODO compute actual index, or hell just use a pointer with
    ; a sentinel at the end
    ; TODO this is meant to compare to our current grid line but
    ; it doesn't really apply once we get to this point
    ;ld a, c
    ;cp a, [hl]
    ; TODO varies with direction Auughhh
    ;jr nz, .skip_entity_check\@

    ; TODO check...  more...  thoroughly......  i guess?
    ; We're blocked, so, set our position to be the thing we
    ; hit, minus its radius, minus OUR radius
    ld b, [hl]
    inc hl
    ld c, [hl]
    ldh a, [h_our_radius]
IF _is_pos
    SubAFrom16 bc
ELSE
    AddATo16 bc
ENDC

    ld a, b
    ld [_p_pos], a
    ld a, c
    ld [_p_pos + 1], a
    pop hl
    jp \3

.skip_entity_check\@:
    pop hl


    ; Done, and we never hit anything!  Update our position to
    ; what was requested
    ld a, [_p_vel]
    ld hl, _p_pos + 1
    add a, [hl]
    ld [hl-], a
    ld a, [hl]
IF _is_pos
    adc a, 0
ELSE
    adc a, $ff
ENDC
    ; XXX compensate for world wrapping at 256 by manually
    ; wrapping position here!
    and a, $0f
    ld [hl], a
    jp \3
PURGE _p_pos, _q_pos, _p_vel, _q_vel
ENDM

    ; x axis
    ; Load current x position into bc
    ld hl, anise + Entity_x
    ld a, [hl+]
    ld b, a
    ld c, [hl]
    ld a, b
    ; Check x velocity (i.e. movement).  Positive and negative
    ; are, alas, separate cases; zero means skip entirely
    ld hl, anise + Entity_vx
    ld a, [hl]
    cp a, $80
    jp nc, .negative_x
    or a
    jp z, .done_x
    ; FIXME: risk of over/underflow near edges with the +1/-1

.positive_x:
    CheckCollision 0, 1, .done_x
.negative_x:
    CheckCollision 0, 0, .done_x
.done_x:

    ; y axis
    ; Load current y position into bc
    ld hl, anise + Entity_y
    ld a, [hl+]
    ld b, a
    ld c, [hl]
    ld a, b
    ; Check y velocity (i.e. movement).  Positive and negative
    ; are, alas, separate cases; zero means skip entirely
    ld hl, anise + Entity_vy
    ld a, [hl]
    cp a, $80
    jp nc, .negative_y
    or a
    jp z, .done_y

.positive_y:
    CheckCollision 1, 1, .done_y
.negative_y:
    CheckCollision 1, 0, .done_y
.done_y:

    ; ----------------------------------------------------------
    ; Update sprite animation

    ; Use e to store whether the sprite we ultimately show this
    ; frame is a new one -- i.e. if the facing or pose changed.
    ld e, 0

    ; Figure out which way we're facing, based on which (if any)
    ; button is newly-pressed this frame
    ; TODO hey i could just keep shifting and...  wait is there any point to that, maybe it's faster?
    ; TODO whoops, this doesn't work if you let go of the button.
    ; Previous facing goes in b
    ld hl, anise + Entity_facing
    ld b, [hl]
    ld a, [buttons_pressed]
    bit PADB_LEFT, a
    jr z, .skip_left2
    ld [hl], FACING_LEFT
    jr .skip_down2
.skip_left2:
    bit PADB_RIGHT, a
    jr z, .skip_right2
    ld [hl], FACING_RIGHT
    jr .skip_down2
.skip_right2:
    bit PADB_UP, a
    jr z, .skip_up2
    ld [hl], FACING_UP
    jr .skip_down2
.skip_up2:
    bit PADB_DOWN, a
    jr z, .skip_down2
    ld [hl], FACING_DOWN
.skip_down2:

    ; Restart the animation if the facing changed
    ld a, [hl]
    cp b
    jr z, .skip_facing_changed
    ld e, 1
.skip_facing_changed:

    ; First figure out what the animation /is/.  For now, there
    ; are only two options: idle and walking.  If we tried to
    ; move (i.e. any direction is currently pressed), we're
    ; walking; otherwise, idle.
    ; TODO this is not very good and won't work for non-players
    ; TODO this should really be an 'idle' pose and reset from
    ; the beginning etc
    ld a, [buttons]
    and a, PADF_UP | PADF_DOWN | PADF_LEFT | PADF_RIGHT
    ; Use 1 for walking, 0 for idle for now
    ld d, 0
    jr z, .pose_idle
    ld d, 1
.pose_idle:

    ; Restart the animation if the pose changed
    ld a, [anise + Entity_pose]
    cp d
    jr z, .pose_unchanged
    ld e, 1
.pose_unchanged:

    ; Check whether to actually do anything.
    ; If the animation is forcibly being restarted, we restart
    ; at frame zero and skip these checks.
    bit 0, e
    jr z, .static_pose_check
    ld a, d
    ld [anise + Entity_pose], a
    ; FIXME this cleverly starts walking at frame 1, which means
    ; tapping a direction will continually put a foot out rather
    ; than gradually sliding.  but it's not a /great/ solution
    ld [anise + Entity_frame], a
    jr .skip_static_pose_check

.static_pose_check:
    ; If this is a static pose (i.e. idle), there's only one
    ; frame of animation, so nothing to do here.
    ld a, d
    cp a, 0
    jp z, .no_movement
    ; Otherwise, tick down the frame counter.  If it doesn't hit
    ; zero, there's nothing to do.
    ld a, [anise + Entity_countdown]
    dec a
    ld [anise + Entity_countdown], a
    jp nz, .no_movement

    ; If it /did/ hit zero, bump to the next frame.  (This
    ; happens before the following label so it doesn't clobber
    ; setting the frame to 0 for a restarted animation.)
    ld a, [anise + Entity_frame]
    inc a
    and a, 4 - 1
    ld [anise + Entity_frame], a

.skip_static_pose_check:

    ; This is the start of a frame, so restart the countdown
    ld a, ANIMATION_LENGTH
    ld [anise + Entity_countdown], a

    ; Anise has a unique sprite, so overwrite the current tile
    ; rather than changing tiles
    ld hl, SPRITES_ANISE + SPRITESO_TILES

    ; Armed with a pose and a frame, find where it actually is!
    ; First find the frame's row; there are 4 facing columns in
    ; a sheet, so stride over 4 facings * 3 sprites per frame
    ld a, [anise + Entity_frame]
    or a
    jr z, .skip_stride_frame
    ld bc, 4 * 3 * BYTES_PER_OBJECT
.stride_frame:
    add hl, bc
    dec a
    jr nz, .stride_frame
.skip_stride_frame:

    ; Next find the facing, which is the column
    ld a, [anise + Entity_facing]
    and a, %11                      ; cap to 4, just in case
    jr z, .skip_stride_facing       ; handle zero case
    ld bc, 3 * BYTES_PER_OBJECT
.stride_facing:
    add hl, bc
    dec a
    jr nz, .stride_facing
.skip_stride_facing:

    ; Store the new sprite address, to be updated during vblank
    ld a, h
    ld [anise_sprites_address], a
    ld a, l
    ld [anise_sprites_address + 1], a

.no_movement:
    ; End-of-frame cleanup
    call sort_entities
    call update_oam

    ; Loop again when done
    jp main

; Other blocking actions
.do_show_dialogue:
    call show_dialogue
    jp main


; Fetches properties for the map cell at the given coordinates.
; In: bc = x/y coordinates
; Out: a = flags
get_cell_flags:
    push hl
    push de
    ; Get the cell first
    ld hl, MAP_TEST_DATA
    ; Add x coordinate
    ld d, 0
    ld e, b
    add hl, de
    add hl, de
    ; Add y coordinate, with stride of 32, which we can do
    ; without multiplying by shifting left 5
    ld d, c
    srl d
    srl d
    srl d
    ld a, c
    swap a
    sla a
    and a, $e0
    ld e, a
    add hl, de
    add hl, de
    ; Get the cell itself
    ld a, [hl]
    ; I don't have real flags at the moment, so, fake it
    cp a, 2
    jr z, .blocking
    jr .not_blocking
.blocking:
    ld a, 1
    jr .done
.not_blocking:
    xor a
.done:
    pop de
    pop hl
    ret

; populates buttons, buttons_released, buttons_pressed
; NOTE: trashes a, b, hl
read_input:
    ; Populating the request bits is asynchronous, and we need a
    ; slight delay to get a reliable read, which is most easily
    ; done by just reading several times.  This comes from the
    ; manual so it oughta be correct
    ld a, $20                   ; read dpad
    ldh [rP1], a
    ld a, [rP1]
    ld a, [rP1]
    cpl                         ; zero bits indicate presses!
    and a, $0f                  ; mask off just the dpad bits
    ld b, a                     ; store dpad bits in b

    ld a, $10                   ; read buttons
    ldh [rP1], a
    ld a, [rP1]                 ; even more unreliable!
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    cpl
    and a, $0f
    swap b                      ; put dpad in the high nybble
                                ; (matches GBA bit order)
    or a, b                     ; combine with dpad

    ; a now contains the current buttons
    ld hl, buttons
    ld b, [hl]                  ; b <- previous buttons
    ld [hl], a                  ; a -> current buttons
    cpl
    and a, b
    ld [buttons_released], a    ; a = ~new & old, i.e. released
    ld a, [hl]                  ; a <- current buttons
    cpl
    or a, b
    cpl
    ld [buttons_pressed], a     ; a = ~(~new | old), i.e. pressed
    ret

SECTION "Utility code", ROM0
; idle until next vblank
wait_for_vblank:
    xor a                       ; clear the vblank flag
    di                          ; avoid irq race after this ld
    ld [vblank_flag], a
.vblank_loop:
    ei
    halt                        ; wait for interrupt
    di
    ld a, [vblank_flag]         ; was it a vblank interrupt?
    and a
    jr z, .vblank_loop          ; if not, keep waiting
    ei
    ret

; TODO these could be sped up somewhat by partial unrolling
; copy c bytes from de to hl
; NOTE: c = 0 means to copy 256 bytes!
copy:
    ld a, [de]
    inc de
    ld [hl+], a
    dec c
    jr nz, copy
    ret

; copy bc bytes from de to hl
; NOTE: bc must not be zero
copy16:
    ld a, [de]
    inc de
    ld [hl+], a
    dec bc
    ; dec bc doesn't set flags, so gotta check by hand
    ld a, b
    or a, c
    jr nz, copy16
    ret

; fill c bytes starting at hl with a
; NOTE: c must not be zero
fill:
    ld [hl+], a
    dec c
    jr nz, fill
    ret



SECTION "Important twiddles", WRAM0[$C000]
vblank_flag:
    db
buttons:
    db
buttons_pressed:
    db
buttons_released:
    db
pending_mode_switch::
    db
; TODO replace this with a general sprite update queue
anise_sprites_address:
    dw

entities_sorted_x_pos:
    ds MAX_ENTITIES * 3
entities_sorted_y_pos:
    ds MAX_ENTITIES * 3
entities_collidable_count:
    db
entities_collidable:
    ds MAX_ENTITIES * 3

SECTION "Font", ROMX
text:
    db "hi im chees.\nBall", 0
    db "The quick brown fox jumps over the\nlazy dog's back.  AOOWWRRR!!!!", 0
    db "Jackdaws love my big sphinx of quartz.", 0
; FONT
font: include "font.inc"

SECTION "Text buffer", WRAM0[$C200]
text_buffer:
    ; Text is up to 8x16 but may span two columns, so carve out
    ; enough space for four tiles
    ds $40
text_x:
    ; x offset within the current tile at which to render
    db
text_y:
    db

SECTION "Text rendering", ROM0
PALETTE_TEXT:
    dcolor $000000
    dcolor $ffffff
    dcolor $999999
    dcolor $333333

SCREEN_WIDTH_TILES EQU 20
CANVAS_WIDTH_TILES EQU 32
SCREEN_HEIGHT_TILES EQU 18
CANVAS_HEIGHT_TILES EQU 32
TEXT_START_TILE_1 EQU 128
TEXT_START_TILE_2 EQU TEXT_START_TILE_1 + SCREEN_WIDTH_TILES * 2

show_dialogue:
    ; SETUP
    ; Slide up the dialogue window (by showing one row of black
    ; at a time, starting at the bottom)

    ; Use four vblanks
    call wait_for_vblank

    ; Set up palette during this first vblank, too
    ld a, %10111000
    ld [rBCPS], a
    ld hl, PALETTE_TEXT
    REPT 8
    ld a, [hl+]
    ld [rBCPD], a
    ENDR

    ; Blank out tile 255
    ld a, 1
    ldh [rVBK], a
    xor a
    ld c, BYTES_PER_TILE
    ld hl, $8800 + 255 * BYTES_PER_TILE
    call fill

    ; Row 4
    ld hl, $9800 + CANVAS_WIDTH_TILES * (SCREEN_HEIGHT_TILES - 1)
    ld b, TEXT_START_TILE_2 + 1
    call fill_tilemap_row

    ; Row 3
    call wait_for_vblank
    ld hl, $9800 + CANVAS_WIDTH_TILES * (SCREEN_HEIGHT_TILES - 2)
    ld b, TEXT_START_TILE_2
    call fill_tilemap_row

    ; Row 2
    call wait_for_vblank
    ld hl, $9800 + CANVAS_WIDTH_TILES * (SCREEN_HEIGHT_TILES - 3)
    ld b, TEXT_START_TILE_1 + 1
    call fill_tilemap_row

    ; Row 1
    call wait_for_vblank
    ld hl, $9800 + CANVAS_WIDTH_TILES * (SCREEN_HEIGHT_TILES - 4)
    ld b, TEXT_START_TILE_1
    call fill_tilemap_row

    ; Zero out the tile buffer
    xor a
    ld hl, text_buffer
    ld c, $40
    call fill

    ; ----------------------------------------------------------
    ; Setup done!  Real work begins here
    ; de: text cursor + current character tiles
    ; hl: current VRAM tile being drawn into + buffer pointer
    ld a, 4
    ld [text_y], a
    ld b, 4
    ld de, text
    ld hl, $8800

    ; The basic problem here is to shift a byte and split it
    ; across two other bytes, like so:
    ;      yyyyy YYY
    ;   xxx00000 00000000
    ;           ↓
    ;   xxxyyyyy YYY00000
    ; To do this, we rotate the byte, mask the low bits, OR them
    ; with the first byte, restore it, mask the high bits, and
    ; then store that directly as the second byte (which should
    ; be all zeroes anyway).
.next_letter:
    ld a, [de]                  ; get current character
    and a                       ; if NUL, we're done!
    jp z, .done
    inc de                      ; otherwise, increment

    ; Handle special characters
    ; newline
    cp a, 10
    jp z, .handle_newline

    ; Get the font character
    push de                     ; from here, de is tiles
    ; Alas, I can only add to hl, so I need to compute the font
    ; character address in hl and /then/ put it in de.  But I
    ; already pushed de, so I can use that as scratch space.
    push hl
    sub a, 32   ; TODO temporary...?
    ld hl, font
    and a
    jr z, .skip_letter_stride
    ld de, 33                   ; 1 width byte + 16 * 2 tiles
    ; TODO can we speed striding up with long mult?
.letter_stride:
    add hl, de
    dec a
    jr nz, .letter_stride
.skip_letter_stride:
    ld d, h                     ; move char tile addr to de
    ld e, l

    ld a, [de]                  ; read width
    inc de

    ; Copy into current tiles
    push af                     ; stash width
    ld c, 32                    ; 32 bytes per row
    ld hl, text_buffer
; FIXME: doesn't work, we write beyond the end of the text
; buffer
;    ; Skip ahead y rows
;    ld a, [text_y]
;    or a
;    jr z, .skip_adjust_y
;    push bc
;    ld bc, 4
;.adjust_y:
;    add hl, bc
;    dec a
;    jr nz, .adjust_y
;    pop bc
;.skip_adjust_y:
    inc b   ; FIXME? this makes the loop simpler since i only test after the dec, but it also is the 1px kerning between characters...
.row_copy:
    ld a, [de]                  ; read next row of character
    ; Rotate right by b - 1 pixels
    push bc                     ; preserve b while shifting
    ld c, $ff                   ; create a mask
    dec b
    jr z, .skip_rotate
.rotate:
    rrca
    srl c
    dec b
    jr nz, .rotate
.skip_rotate:
    push af
    and a, c                    ; mask right pixels
    ; Draw to left half of text buffer
    or a, [hl]                  ; OR with current tile
    ld [hl+], a
    ; Write the remaining bits to right half
    ld a, c                     ; put mask in a...
    cpl                         ; ...to invert it
    ld c, a                     ; then put it back
    pop af                      ; restore unmasked pixels
    and a, c                    ; mask left pixels
    ld [hl+], a                 ; and store them!
    ; Loop and cleanup
    inc de                      ; next row of character
    pop bc                      ; restore counter!
    dec c
    jr nz, .row_copy
    pop af                      ; restore width

    ; Draw the buffered tiles to vram
    ; The text buffer is treated like it's 16 pixels wide, but
    ; VRAM is of course only 8 pixels wide, so we need to do
    ; this in two iterations: the left two tiles, then the right
    ; TODO explain this with a fucking diagram because i feel
    ; like i'm wrong about it anyway
    pop hl                      ; restore hl (VRAM)
    push af                     ; stash width, again
    call wait_for_vblank        ; always wait before drawing
    push bc
    push de
    ; Draw the left two tiles
    ld c, $20
    ld de, text_buffer
.draw_left:
    ld a, [de]
    inc de
    inc de
    ld [hl+], a
    dec c
    jr nz, .draw_left
    ; Draw the right two tiles
    ld c, $20
    ld de, text_buffer + 1
.draw_right:
    ld a, [de]
    inc de
    inc de
    ld [hl+], a
    dec c
    jr nz, .draw_right
    pop de
    pop bc
    pop af                      ; restore width, again

    ; Increment the pixel offset and deal with overflow
    ; TODO it's possible we're at 9 pixels wide, thanks to the
    ; kerning pixel, uh oh.  but that pixel would be empty,
    ; right?  wait, no, it comes /before/...  well fuck
    ; TODO actually that might make something weird happen due
    ; to the inc b above, maybe...?
    dec b
    add a, b                    ; a <- new x offset
    ld bc, -32                  ; move the VRAM pointer back...
    add hl, bc                  ; ...to the start of the tile
    cp a, 8
    jr nc, .wrap_to_next_tile
    ; The new offset is less than 8, so this character didn't
    ; draw into the next tile.  Move the VRAM pointer back
    ; another two tiles, to the column we started in
    add hl, bc
    jr .done_wrap
.wrap_to_next_tile:
    ; The new offset is 8 or more, so this character drew into
    ; the next tile.  Subtract 8, but also shift the text buffer
    ; by copying all the "right" tiles over the "left" tiles
    sub a, 8                    ; a >= 8: subtract tile width
    push hl
    push af
    ld hl, text_buffer + $40 - 1
    ld c, $20
.shift_buffer:
    ld a, [hl-]
    ld [hl-], a
    dec c
    jr nz, .shift_buffer
    pop af
    pop hl
.done_wrap:
    ld b, a                     ; either way, store into b

    ; Loop
    pop de                      ; pop text pointer
    jp .next_letter

.done:
.wait:
    call wait_for_vblank
    call read_input
    ld a, [buttons_pressed]
    bit PADB_A, a
    jr z, .wait

    ; Remember to reset bank to 0!
    xor a
    ldh [rVBK], a
    ret


.handle_newline:
    ; Bump us onto the next row
    ; TODO obviously do something more interesting if there are
    ; more than two lines of text
    ; Empty the text buffer
    xor a
    ld hl, text_buffer
    ld c, $40
    call fill
    ; Move char cursor to the next line
    ld hl, $8800 + 2 * SCREEN_WIDTH_TILES * BYTES_PER_TILE
    ; Reset the text offsets
    ld a, 4
    ld [text_y], a
    ld [text_x], a
    ld b, 4
    call wait_for_vblank
    jp .next_letter


; Fill a row in the tilemap in a way that's helpful to dialogue.
; TODO document better.
; TODO this should, you know, probably use the window or be
; configurable or sssomething
; hl: where to start filling
; b: tile to start with
fill_tilemap_row:
    ; Populate bank 0, the tile proper
    xor a
    ldh [rVBK], a

    ld c, SCREEN_WIDTH_TILES
    ld a, b
.loop0:
    ld [hl+], a
    add a, 2
    dec c
    jr nz, .loop0

    ; Populate bank 1, the bank and palette
    ld a, 1
    ldh [rVBK], a
    ld a, %00001111  ; bank 1, palette 7
    ld c, SCREEN_WIDTH_TILES
    dec hl
.loop1:
    ld [hl-], a
    dec c
    jr nz, .loop1

    ret
